using System;
using System.Linq;
using System.Net.Security;


namespace DiffiHellman
{
    class Program
    {
        static void Main(string[] args)
        {
            int  p = 17, g = 5; // p and g are publicly available, a and b are private values
            
            int X;
            
            String a = Console.ReadLine();
            String b = Console.ReadLine();
            
            while(!Int32.TryParse(a, out X))
            {
                Console.WriteLine("Not a valid number, try again.");

                a = Console.ReadLine();
            }
            
            while(!Int32.TryParse(b, out X))
            {
                Console.WriteLine("Not a valid number, try again.");
                b = Console.ReadLine();
            }
            
            var keyA = InputGenerator(g, Convert.ToInt32(a), p);
            var keyB = InputGenerator(g, Convert.ToInt32(b) , p);

            Console.WriteLine($"Key generated by A is - {keyA} - while key generated by B is - {keyB} - ");

            var secretA = InputGenerator(keyA, Convert.ToInt32(b), p);
            var secretB = InputGenerator(keyB, Convert.ToInt32(a), p);

            Console.WriteLine($"Secret generated by A is - {secretA} - secret generated by B is - {secretB} -");

            Console.ReadKey();

        }

        static int InputGenerator(int pKeyBase, int pow, int p)
        {
            int remainder = 0;
            int multiplier = 1;

            for (int i = pow - 1; i >= 0; i--)
            {
                if (i == pow - 1)
                {
                    multiplier = multiplier * pKeyBase;
                }

                if (multiplier > p)
                {
                    remainder = multiplier % p;
                    multiplier = 1;
                    continue;
                }

                if (multiplier < p && i != pow - 1)
                {
                    multiplier = multiplier * pKeyBase;
                    if (multiplier > p)
                    {
                        remainder = multiplier % p;
                        multiplier = 1;
                    }
                }

                if (remainder != 0)
                {
                    multiplier = remainder * multiplier;
                    remainder = 1;
                }
            }

            return multiplier;
        }

        #region ModPow Not in Use
        static int ModPow(int pbase, int pow)
        {
            int i;
            int pwacc = 1;
            for (i = 0; i < pow; i++)
            {
                pwacc = pwacc * pbase;
            }

            return pwacc;
        }

        #endregion


    }
}